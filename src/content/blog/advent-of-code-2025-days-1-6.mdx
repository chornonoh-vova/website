---
title: "Advent of Code 2025, part 1"
description: "My journey through AoC 2025, days 1-6"
date: 2025-12-01
---

import { Day1 } from "../../components/aoc-2025/Day1";

Welcome to Advent of Code 2025 ðŸŽ‰

On this page I will be documenting my struggles, solutions and, sometimes visualizations
for days of this challenge. Let's begin!

## Boilerplate

Before we start for real though, there's some repeating code to read the file that is
passed as an argument:

```ts
import { readFile } from "node:fs/promises";
import { argv, exit } from "node:process";

const filename = argv[2];

if (!filename) {
  console.error("expect filename");
  exit(1);
}

const input = (await readFile(filename, "utf-8")).trim();
```

Every day begins with this boilerplate, so I'll include it once at the beginning.

## Day 1

The task is pretty straightforward (as I find it later), but I started over-complicating
the solution, and it backfired quickly.

I've solved the first part mathematically:

```ts
const instructions = input.split("\n");

class Safe {
  #dial: number;
  cnt: number;

  constructor(initial: number) {
    this.#dial = initial;
    this.cnt = 0;
  }

  turnLeft(amount: number) {
    this.#dial = (((this.#dial - amount) % 100) + 100) % 100;
    this.#checkCounter();
  }

  turnRight(amount: number) {
    this.#dial = (this.#dial + amount) % 100;
    this.#checkCounter();
  }

  #checkCounter() {
    if (this.#dial === 0) {
      this.cnt++;
    }
  }
}

const safe = new Safe(50);

for (const instruction of instructions) {
  const dir = instruction.substring(0, 1);
  const amount = parseInt(instruction.substring(1));

  if (dir === "L") {
    safe.turnLeft(amount);
  } else {
    safe.turnRight(amount);
  }
}

console.log("part 1:", safe.cnt);
```

But for the second part... Well, I couldn't figure out how to calculate everything
essentially in one operation. So I switched back to simulating the whole process,
and in doing so, I've simplified and refactored it a lot:

```ts
type Direction = "L" | "R";

class Safe {
  #dial: number;
  part1: number;
  part2: number;

  constructor(initial = 50) {
    this.#dial = initial;
    this.part1 = 0;
    this.part2 = 0;
  }

  turn(direction: Direction, amount: number) {
    const dir = direction === "L" ? -1 : 1;

    for (let i = 0; i < amount; ++i) {
      this.#dial += dir;
      this.#dial %= 100;

      if (!this.#dial) {
        this.part2++;
      }
    }

    if (!this.#dial) {
      this.part1++;
    }
  }
}

const safe = new Safe();

for (const instruction of instructions) {
  const direction = instruction.substring(0, 1) as Direction;
  const amount = parseInt(instruction.substring(1));

  safe.turn(direction, amount);
}

console.log("part 1:", safe.part1);
console.log("part 2:", safe.part2);
```

And this was quite a good starting point for visualization, that I set out to
implement, after seeing some inspiring visuals on Reddit.

Here it is:

<Day1 client:load />

You can try uploading the following file, and clicking "Simulate":

```txt
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
```

## Day 2

The second day was more straightforward to me, and it begins with parsing, which is basically splitting ranges and splitting every range individually:

```ts
const ranges = input.split(",").map((r) => r.split("-").map(Number));
```

The first part of the puzzle is to find the "invalid" numbers in the ranges that we've just parsed, and sum them up. An invalid number is a number in which the sequence of digits repeats twice. For example `11`, `123123` or `1122511225`. I've decided to split every number's string representation in the middle and just compare two parts. Here's my implementation:

```ts
const invalid1: number[] = [];

for (const [start, end] of ranges) {
  for (let n = start; n <= end; ++n) {
    const s = n.toString();
    if (s.length % 2 !== 0) {
      continue;
    }

    const [left, right] = [
      s.substring(0, s.length / 2),
      s.substring(s.length / 2),
    ];

    if (left === right) {
      invalid1.push(n);
    }
  }
}

const part1 = invalid1.reduce((prev, curr) => prev + curr, 0);

console.log("part 1:", part1);
```

Additionally, I'm skipping the odd-length numbers, as they won't have repeating sequences anyway.

The second part was trickier though. Now, the sequences of numbers can repeat more than two times. For example, `121212` previously would have been considered valid, but with new rules, it will be considered invalid.

To implement this logic, I'm iterating over all possible sizes (from 1 and up to `s.length / 2`) and splitting the string into multiple parts. And to verify whether the number is invalid I'm comparing every part. Here's my implementation:

```ts
const invalid2: number[] = [];

for (const [start, end] of ranges) {
  for (let n = start; n <= end; ++n) {
    const s = n.toString();

    for (let size = 1; size <= Math.floor(s.length / 2); ++size) {
      if (s.length % size !== 0) {
        continue;
      }

      const parts: string[] = [];

      for (let i = 0; i < s.length; i += size) {
        parts.push(s.substring(i, i + size));
      }

      if (parts.every((p) => p === parts[0])) {
        invalid2.push(n);
        break;
      }
    }
  }
}

const part2 = invalid2.reduce((prev, curr) => prev + curr, 0);

console.log("part 2:", part2);
```

You can notice a sneaky little `break` after we've identified an invalid number, it is needed there to avoid counting the same number multiple times. For example, number `222222` can be split up as `['2','2','2','2','2','2']` or `['22','22','22']` or `['222','222']` which all satisfy our requirement. And in the first version I've pushed the same number multiple times ðŸ˜… Which led to over-counting.

Another way to solve this issue was to store all of the invalid numbers in a `Set`, as it allows only unique numbers. But this approach is much simpler, in my opinion.

## Day 3

On this day, the task was really interesting: find consecutive maximums in array of digits. But let's start with parsing:

```ts
const banks = input.split("\n").map((line) => line.split("").map(Number));
```

It's pretty straightforward - every line is transformed into array of numbers.

For the first idea, I immediately jumped into solving the problem with brute force approach, and it worked fine for 2 maximums that are required in the first part. But for the second part you need to find 12 maximums! Of course, you can write 12 `for` loops inside of one another ðŸ™ƒ But I took a step back to re-think my brute-force solution and improve it to be linear.

The idea is to greedily find the maximum number possible, remember it, and then start looking for maximum but from the next index of the previous one. The main catch for me in this task was to limit the index that we are looking for. For example, if we are looking for the first number, we can look up to the `batteries.length - 11` index, for second - up to `batteries.length - 10` and when looking for 12th - up to the end of the array.

Here's how I implemented both parts in one function:

```ts
function findTotalJoltage(size: number) {
  const maximums: number[] = [];

  for (const batteries of banks) {
    let max = 0;
    let maxIdx = -1;

    for (let s = size - 1; s >= 0; --s) {
      let maxInner = -1;

      for (let i = maxIdx + 1; i < batteries.length - s; ++i) {
        if (batteries[i] > maxInner) {
          maxInner = batteries[i];
          maxIdx = i;
        }
      }

      max = max * 10 + maxInner;
    }

    maximums.push(max);
  }

  return maximums.reduce((prev, curr) => prev + curr, 0);
}

console.log("part 1:", findTotalJoltage(2));
console.log("part 2:", findTotalJoltage(12));
```

There's also a bonus trick here: instead of converting every digit back to string, concatenating and then parsing the whole result back to number, this line:

```ts
max = max * 10 + maxInner;
```

Will instead directly add a digit to the number!
